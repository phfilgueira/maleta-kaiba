// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // Uses connection pooling
}

// 1. O Usuário do Sistema
model User {
  id       String @id @default(uuid())
  email    String @unique
  password String
  UserName     String

  // Relacionamentos
  collection UserCard[] // A coleção deste usuário
  decks      Deck[] // Os decks deste usuário
}

// 2. A Definição da Carta (Dados estáticos da carta)
// O ID aqui deve ser o mesmo ID composto gerado no frontend (Set-Raridade-ArtID)
model Card {
  id             String   @id
  name_en           String
  name_pt        String?
  type           String
  typeTags       String[] // Array nativo do Postgres (ex: ['Dragon', 'Synchro', 'Effect'])
  attribute      String?
  level          Int?
  atk            Int?
  def            Int?
  description    String
  description_pt String?
  imageUrl       String
  cardCode       String
  collectionCode String
  collectionName String?
  rarity         String
  releaseDate    String?

  // Relacionamento reverso (quais usuários têm esta carta)
  owners UserCard[]
}

// 3. A Tabela de Ligação (Coleção do Usuário)
// Define quantas cópias de uma carta específica um usuário possui
model UserCard {
  userId    String
  cardId    String
  quantity  Int
  dateAdded Float // Timestamp (number no JS)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  card Card @relation(fields: [cardId], references: [id], onDelete: Cascade)

  @@id([userId, cardId]) // Chave primária composta (um usuário só tem 1 registro por carta única)
}

// 4. Decks
model Deck {
  id          String @id
  name        String
  dateCreated Float
  dateUpdated Float
  userId      String

  // Armazenamos os IDs das cartas como arrays de strings.
  // O Postgres suporta isso nativamente e facilita a sincronia com seu frontend atual.
  mainDeck  String[]
  extraDeck String[]
  sideDeck  String[]

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}